#include <bits/stdc++.h>

using namespace std;

/*
    1.构造函数是类创建对象时自动调用的函数，用来初始化成员变量或进行资源分配。

        ✔ 特点

        名字与类名相同

        没有返回值（连 void 都不能写）

        可以重载（多个版本，参数不同）

        创建对象时自动调用
    
    2.析构函数是对象销毁时自动调用，用于释放资源。

        ✔ 特点

        名字前加 ~

        不能重载

        没有参数、不能有返回值

        程序结束或对象离开作用域时自动调用
*/

//simple example
class A{
    int x;

public:
    //默认构造函数
    A() {
        x=0;
        cout << "默认构造" << endl;
    }

    //带参构造函数
    A(int v) : x(v) {   // 初始化列表
        cout << "带参构造" << endl;
    }

    //拷贝构造函数
    A(const A& other) : x(other.x) {
        cout << "拷贝构造" << endl;
    }

    //转移构造函数
    //移动构造函数用于高效地转移资源，而不是拷贝资源。
    //当一个对象是临时对象或将被丢弃时，你可以把它的资源“搬走”，而不是复制一份。
    //把资源从 other 转移到当前对象，然后把 other 的资源指针设为安全状态（如 nullptr）
    A(A&& other) noexcept {
        this->x = other.x;
        other.x = 0;
    }

    ~A() {
        cout << "析构函数" << endl;
    }

    /*
        析构函数除了在对象消亡时会被自动调用外，也可以在对象生存期内显式调用，这时并不是让对象消亡，而是暂时归还对象额外申请的资源。
        例如，
        String s1("abcd");
        ......
        s1.~String(); //把字符串s1清空，对象并未消亡！
        ... s1 ... //仍然可以使用对象s1
        再例如，
        Stack st;
        ... st.push ... st.pop ...
        st.~Stack(); //清空栈st
        ... st.push ... st.pop ... //仍然可以使用栈对象st

    */
};

//example
class Buffer {
public:
    int* data;
    int size;

    // 普通构造函数
    Buffer(int s) : size(s) {
        data = new int[size];
        cout << "构造: 分配 " << size << " 个元素\n";
    }

    // 拷贝构造（深拷贝）
    /*
        在程序中，如果没有为某个类提供拷贝构造函数，则编译器将会为其生成一个隐式拷贝构造函数（浅拷贝）。
        隐式拷贝构造函数将逐个成员进行拷贝初始化：
        对于非对象成员，它采用通常的拷贝操作
        对于成员对象，则调用成员对象类的拷贝构造函数来对成员对象进行初始化（递归定义！）
    */
    Buffer(const Buffer& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);//把 other.data 指向的数组里的元素，拷贝 size 个，复制到 data 指向的数组里。
        cout << "拷贝构造: 深拷贝\n";
    }

    // **移动构造函数**
    Buffer(Buffer&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;  // 防止析构时重复释放
        other.size = 0;
        cout << "移动构造: 资源转移\n";
    }

    // 析构
    ~Buffer() {
        delete[] data;
        cout << "析构: 释放资源\n";
    }
};

Buffer create() {
    return Buffer(10); // 临时对象 => 可移动
}

int main(){
    //转移构造函数触发情况：
    //1）返回局部对象：
    Buffer b = create();// 调用移动构造（或被优化）
    //使用 std::move：
    Buffer a(20);
    Buffer b = std::move(a); // 强制移动
    //向容器push_back:
    vector<Buffer> v;
    v.push_back(Buffer(30)); // 临时对象，移动构造
}

/*
    在创建对象时，
    如果没有指定调用对象类中哪一个构造函数，则调用默认构造函数初始化。
    也可以显式地指定调用对象类的某个构造函数。
*/

/*
    在创建包含成员对象的对象时，除了会自动调用本身类的构造函数外，还会自动去调用成员对象类的构造函数。
    通常是调用成员对象类的默认构造函数。
    如果要调用成员对象类的非默认构造函数，需要在包含成员对象的对象类的构造函数成员初始化表中显式指出！
    包含成员对象的对象消亡时，除了会自动调用本身类的析构函数外，还会自动去调用成员对象类的析构函数。

    包含成员对象的对象创建时，
    先调用本身类的构造函数，但在进入函数体之前，会去调用成员对象类的构造函数，然后再执行本身类构造函数的函数体！
    也就是说，构造函数的成员初始化表（即使没显式给出）中有对成员对象类的构造函数的调用代码。
    若包含多个成员对象，这些成员对象构造函数的调用次序则按它们在 "本对象类中的说明次序" 进行。

    包含成员对象的对象消亡时，
    先调用本身类的析构函数，本身类析构函数的函数体执行完之后，再去调用成员对象类的析构函数！
    也就是说，析构函数的函数体最后有对成员对象类的析构函数的调用代码！
    如果有多个成员对象，则成员对象析构函数的调用次序按它们在 "本对象类中的说明次序的逆序" 进行。
*/